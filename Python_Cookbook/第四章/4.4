## 一个完整的迭代协议

**问题**

你正在创建一个可以迭代的自定义的对象，你需要一个简单的方法来实现一个完整的迭代协议。

**解决方案**

到目前为止，最简单的方法实现完整的迭代协议就是用生成器。在 [第四章 4.2](4-2.md), Node 类是用来代表树结构。也许你想要实现一个可以横跨节点的深度优先方法，请看下面的例子：


  class Node:
      def __init__(self, value):
          self._value = value
          self._children = []

      def __repr__(self):
          return 'Node({!r})'.format(self._value)

      def add_child(self, node): # 向一个节点里面加入另外的节点
          self._children.append(node)

      def __iter__(self): # 一个子节点的生成器
          return iter(self._children)

      def depth_first(self):
          yield self
          for c in self:
              yield from c.depth_first()

  # 示例
  if __name == '__main__':
      root = Node(0)
      child_1 = Node(1)
      child_2 = Node(2)
      root.add_child(child_1)
      root.add_child(child_2)
      child_1.add_child(Node(3))
      child_1.add_child(Node(4))
      child_2.add_child(Node(5))

      for ch in root.depth_first():
          print(ch)
      # Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)
        
        
在这段代码里， depth_first() 方法是比较简单的。 首先它 yield 了他自己的节点，然后迭代了这个节点里的每个子节点的 depth_first() 方法。（通过 yield from ）
  
**讨论**
  
Python 的迭代器要求 __iter()__ 返回一个特殊的迭代器来实现 __next__() 操作，并且将 StopIteration 异常作为结束标志。 然而，真的实现这个是一件麻烦的事情。比如，下面的代码就展示出了另一种实现 depth_first() 方法，用一个相关的迭代器类。

    class Node:
        def __init__(self, value):
            self._value = value
            self._children = []

        def __repr__(self):
           return 'Node({!r})'.format(self._value)

        def add_child(self, other_node):
           self._children.append(other_node)

        def __iter__(self):
           return iter(self._children)

        def depth_first(self):
            return DepthFirstIterator(self)

    class DepthFirstIterator(object):
        '''
        深度优先算法
        '''
        def __init__(self, start_node):
            self._node = start_node
            self._children_iter = None
            self._child_iter = None

        def __iter__(self):
            return self

        def __next__(self):
            if seld._children_iter is None:
                self._children_iter = iter(self._node)
                return self._node

            elif self._child_iter:
                try:
                    next_child = next(self._child_iter)
                    return next_child
                except StopIteration:
                    self._child_iter = None
                    return next(self)

            else:
                self._child_iter = next(self._children_iter).depth_first()
                return next(self)
                    
这个 DepthFirstIterator 类与生成器是一个版本，到那时为了再迭代的过程中维护迭代器的状态导致很混乱。幸运的是，并没有人回写像这样的代码，用你的生成器去取代它。
  
**关于yield from**

yield from 是 Python3.3 后新加的语言结构
yeild from 可以简化 for 循环的yield 表达式，比如：
    
    >>> def gen():
    ...     for c in 'AB':
    ...         yield c
    ...     for i in range(1, 3):
    ...         yield i
    ...
    >>> list(gen())
    ['A', 'B', 1, 2]
    
可以改写为：

    >>> def gen():
    ...     yield from 'AB'
    ...     yield from range(1, 3)
    ... 
    >>> list(gen())
    ['A', 'B', 1, 2]
